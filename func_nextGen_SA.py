from deap import tools
from func_varOr import varOr
from func_SAselect import select_SA
import random
import time

#####ONE THING have to keep in mind is that the number of ind in parent should be the same as child

def SimulatedAnnealing(population, toolbox, lambda_, cxpb, mutpb, max_iter, T, T_min, alpha,
                   stats=None, halloffame=None, verbose=__debug__):

####this is an upgraded algorithm, that keeps everything unchanged, except for the next generation production
####to select next generation from (parents + offspring), each individual of the next gen is generated by comparing 
######parent and offspring one-by-one, whether offspring enters the pool or not determined by SA algorithm
######loop of SA algorithm: 

##########while current_T >= T_min: 
##########	while iter <= max_iter: 
##########		repeat evolution algorithm, selecte based on acceptance probability
##########		the selection between parent and offspring is based on sorted list, which means, population and offspring are sorted by its evaluation value respectively, then compare by pairs


##	T, T_min = 1, 0.0001
##	alpha = 0.8
##	max_iter = 100
	
	ini_mutpb = mutpb,
	##############evaluate gen(0): population generated at the first time
	logbook = tools.Logbook()
	logbook.header = ['gen', 'temp'] + (stats.fields if stats else [])
	# Evaluate the individuals with an invalid fitness
	invalid_ind = [ind for ind in population if not ind.fitness.valid]
	fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)
	# give fitness value to individuals that have not been evaluated
	for ind, fit in zip(invalid_ind, fitnesses):
		ind.fitness.values = fit
	if halloffame is not None:
		halloffame.update(population)
		
	record = stats.compile(population) if stats is not None else {}
	
#	logbook.record(gen=0, temp=1, **record)
	# if verbose is TRUE, print the logbook
	if verbose:
		print('temp', '\t', 'generation',  '\t', 'avg',  '\t', 'std',  '\t', 'min',  '\t', 'max')
		print(round(T,2),  '\t', 0,  '\t', round(record['avg'],4),  '\t', round(record['std'],5),  '\t', round(record['min'],4),  '\t', round(record['max'],4))
	#	print(logbook.stream)
	
	i = 0 ##count overall generations
#	best_sol = []
#	population_new = population
	offspring_val = tuple([])
	parent_val = tuple([])

	starttime_ = time.time()
	while T >= T_min:
		print('temp',  '\t', 'generation',  '\t', 'avg',  '\t', 'std',  '\t', 'min',  '\t', 'max')
####SA at the beginning of each temperature
#		if T < 1:
#			population_old = population_new
#			population_new = population
#			population = select_SA(population_old, population_new, T)	
# Begin the generational process (or called local search)

		for gen in range(1, max_iter+1):
			i += 1
			# Vary the population
			offspring = varOr(population, toolbox, lambda_, cxpb, mutpb)
				
			# Evaluate the individuals with an invalid fitness
			invalid_ind = [ind for ind in offspring if not ind.fitness.valid]
			fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)
			for ind, fit in zip(invalid_ind, fitnesses):
				ind.fitness.values = fit
			
			# Update the hall of fame with the generated individuals
			if halloffame is not None:
				halloffame.update(offspring)

			# Select the next generation population
			######first sort offspring and population by its value
#			for p in range(0, len(offspring)):
#				offspring_val = offspring_val + (offspring[p].fitness.values)
#			offspring = [x for _, x in sorted(zip(offspring_val, offspring))]
#			for p in range(0, len(population)):
#				parent_val = parent_val + (population[p].fitness.values)
#			population = [x for _, x in sorted(zip(parent_val, population))]
			
			population[:] = select_SA(population, offspring, T)

			# Update the statistics with the new population
			record = stats.compile(population) if stats is not None else {}

#			logbook.record(gen=gen, temp = T, **record)
			
#			best_sol.append(record['min'])
#			if i >= 50:
#				best_sol = best_sol[1:]
#				if len(set(best_sol[(i-50):i])) == 1:
#					mutpb = 0.2
#			else:
#				mutpb, = ini_mutpb
				
			if verbose:
				print(round(T,2),  '\t', gen,  '\t', round(record['avg'],4),  '\t', round(record['std'],5),  '\t', round(record['min'],4),  '\t', round(record['max'],4))
#				print(logbook.stream)
			
			######replace parents' value with offspring's ones
			offspring_val = tuple([])
			parent_val = tuple([])
			
		T = T*alpha
		print('current temperature', T)
		print('executed 1 level temp:', time.time() - starttime_)
		starttime_ = time.time()
		
	return population, logbook