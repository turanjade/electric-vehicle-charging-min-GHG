from deap import tools
from func_varOr import varOr
from func_SAselect import select_SA
import random

#####ONE THING have to keep in mind is that the number of ind in parent should be the same as child

def SimulatedAnnealing(population, toolbox, lambda_, cxpb, mutpb, max_iter, T, T_min, alpha,
                   stats=None, halloffame=None, verbose=__debug__):

####this is an upgraded algorithm, that keeps everything unchanged, except for the next generation production
####to select next generation from (parents + offspring), each individual of the next gen is generated by comparing 
######parent and offspring one-by-one, whether offspring enters the pool or not determined by SA algorithm
######loop of SA algorithm: 

##########while current_T >= T_min: 
##########	while iter <= max_iter: 
##########		repeat evolution algorithm, selecte based on acceptance probability

##	T, T_min = 1, 0.0001
##	alpha = 0.8
##	max_iter = 100
	
	##############evaluate gen(0): population generated at the first time
	logbook = tools.Logbook()
	logbook.header = ['gen', 'temp', 'nevals'] + (stats.fields if stats else [])
	# Evaluate the individuals with an invalid fitness
	invalid_ind = [ind for ind in population if not ind.fitness.valid]
	fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)
	# give fitness value to individuals that have not been evaluated
	for ind, fit in zip(invalid_ind, fitnesses):
		ind.fitness.values = fit
	if halloffame is not None:
		halloffame.update(population)
		
	record = stats.compile(population) if stats is not None else {}
	logbook.record(gen=0, temp=1, nevals=len(invalid_ind), **record)
	# if verbose is TRUE, print the logbook
	if verbose:
		print(logbook.stream)
			
	while T >= T_min:
			# Begin the generational process
			for gen in range(1, max_iter+1):
				# Vary the population
				offspring = varOr(population, toolbox, lambda_, cxpb, mutpb)
				
				# Evaluate the individuals with an invalid fitness
				invalid_ind = [ind for ind in offspring if not ind.fitness.valid]
				fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)
				for ind, fit in zip(invalid_ind, fitnesses):
					ind.fitness.values = fit
				
				# Update the hall of fame with the generated individuals
				if halloffame is not None:
					halloffame.update(offspring)

				# Select the next generation population
				population[:] = select_SA(population, offspring, T)

				# Update the statistics with the new population
				record = stats.compile(population) if stats is not None else {}
				logbook.record(gen=gen, temp = T, nevals=len(invalid_ind), **record)
				
				if verbose:
					print(logbook.stream)
		T = T*alpha
		
    return population, logbook